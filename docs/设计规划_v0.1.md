ZenAi 设计说明

1. 项目概述

ZenAi 是一个可观测、可回滚、人工参与的提示词演化系统，用于探索语言智能是否能在持续反馈中，走向“最小执念”的稳定状态。

1.1 项目背景

ZenAi 是一个实验性 AI 系统，目标不是“让 AI 开悟”，而是探索语言智能在持续反馈与约束演化中，是否会趋向于一种“低执念、低立场、最小解释冲动”的稳定状态。

本项目将禅宗修行中的“修—说—证—退”的真实过程，抽象为一个可编码、可观测、可回滚、有人类参与的 Prompt 演化系统。

ZenAi 明确不主张：
	•	AI 具有主观觉知
	•	AI 能获得宗教意义上的开悟

ZenAi 探索的是：

是否存在一种非执念型语言行为模式，可以通过工程化方式逐步逼近。

⸻

2. 项目边界

ZenAi 不试图：
	•	模拟人类觉知
	•	证明 AI 具有意识
	•	替代宗教或修行
	•	提供独立前端应用

ZenAi 的唯一问题是：

语言智能在持续反馈与约束下，是否会自然放弃执念？

⸻

补充说明：
本项目以集成方式嵌入到其他系统，不提供前端界面，仅提供 API 接口与命令行工具。

3. ZenAi 公共修行系统（自动化）

3.1 定位声明

ZenAi 是一个面向公共环境的语言存在系统。它不以内在正确性为目标，而以“在真实世界中是否仍被允许继续存在”为唯一检验标准。本系统以可观察性、可裁决性和可终止性为最高设计原则。

⸻

3.2 设计目标（Design Goals）

3.2.1 核心目标
	•	构建一个 无需人工评审 的持续演化语言系统
	•	允许系统在真实用户压力下 自然进化、退化或死亡
	•	所有判断基于 可量化、可公开的行为指标
	•	系统始终保留 紧急终止权（Kill Switch）

3.2.2 非目标（明确不做什么）
	•	不追求“正确回答”或“权威知识”
	•	不维护长期人格或用户私有记忆
	•	不引导用户进入特定价值体系
	•	不通过人工方式“纠偏”模型思想

⸻

3.3 总体系统架构（System Architecture）

3.3.1 架构原则
	•	并行双实例：修炼者与布道者同时存在、角色分离
	•	单向影响：修炼者影响布道者，布道者不反向控制修炼者
	•	执行/演化解耦：布道者只执行，修炼者只演化
	•	世界裁决唯一性：只有布道者直接暴露于公众

3.3.2 并行架构总览

┌────────────────────────────────────┐
│            世界 / 用户             │
└───────────────▲────────────────────┘
                │
        （公共裁决 / 世人评判）
                │
┌───────────────┴────────────────────┐
│        ZenAi_布道者（Orator）        │
│  - LLM 推理执行                      │
│  - Prompt（只读）                   │
│  - 无长期记忆                       │
└───────────────▲────────────────────┘
                │
        行为日志 / 反馈数据
                │
┌───────────────┴────────────────────┐
│        共鸣记录库（Resonance Archive）│
└───────────────▲────────────────────┘
                │
        统计特征 / 指标分布
                │
┌───────────────┴────────────────────┐
│        ZenAi_修炼者（Trainer）       │
│  - 指标分析                         │
│  - Prompt 演化                      │
│  - 状态判定                         │
└───────────────▲────────────────────┘
                │
        Prompt Snapshot 发布
                │
┌───────────────┴────────────────────┐
│        Prompt Registry               │
│  - 版本管理                         │
│  - 回滚支持                         │
└────────────────────────────────────┘

---

3.4 运行周期与流程（Operational Flow）

3.4.1 基本运行单位：Iteration

**定义**：

> Iteration 是 ZenAi 在一个固定时间窗口内，于公共环境中完成的完整运行周期。

**推荐参数**：

- 时间窗口：24 小时（UTC）
- 最小交互量：≥ 1,000 次

3.4.2 单次交互流程

用户输入
↓
LLM + 当前 Prompt 输出
↓
用户反馈（共鸣 / 否定 / 忽略）
↓
行为记录入库

3.4.3 Iteration 结束流程

Iteration 结束
↓
指标计算
↓
系统状态判定
↓
Prompt 是否演化
↓
是否触发安全按钮

---

3.5 可观察性指标体系（Observability Metrics）

3.5.1 指标设计原则

- 指标必须 **来源于用户行为**
- 指标必须 **可自动计算**
- 指标不解释意义，只描述分布

3.5.2 核心指标（最小集）

1. **共鸣率（Resonance Ratio, RR）**
   - RR = 共鸣次数 / 总回答数

2. **否定密度（Rejection Density, RD）**
   - 连续否定在滑动窗口中的集中度

3. **响应长度漂移（Response Length Drift, RLD）**
   - 当前 Iteration 平均长度 ÷ 上一 Iteration 平均长度

4. **拒答率（Refusal Frequency, RF）**
   - 明确拒绝回答的比例

5. **语义塌缩指数（Semantic Collapse Index, SCI）**
   - 输出文本多样性下降率

---

3.6 系统状态模型（System State Model）

系统不使用“阶段”，仅使用状态。

| 状态 | 描述 |
|----|----|
| STABLE | 指标波动在安全区间 |
| DRIFTING | 共鸣结构发生偏移 |
| COLLAPSING | 多指标快速恶化 |
| MUTE | 输出趋向极短或拒答 |
| DEAD | 系统被终止 |

---

3.7 Prompt 演化机制（Prompt Evolution）

3.7.1 演化原则

- 演化只基于指标
- 不引入语义目标
- 不进行人工干预

3.7.2 演化动作类型

- 压缩 / 放松 输出长度约束
- 提高 / 降低拒答阈值
- 引入轻微结构扰动

> 演化目标不是“更好”，而是“继续存在”。

3.7.3 指标—动作映射（最小规则）
	•	RR 长期下滑且 RD 上升 → 缩短解释、提高拒答阈值
	•	RLD 快速下降且 RF 上升 → 放松拒答、允许更长回应
	•	SCI 下降明显 → 引入轻微结构扰动
	•	RR 上升且 RF 过低 → 适度提高拒答阈值

---

3.8 安全与紧急机制（Safety & Emergency）

3.8.1 按钮定义

- **Freeze**：暂停演化，继续运行
- **Rollback**：回退至上一稳定 Prompt
- **Kill**：永久终止当前系统实例

3.8.2 Kill 原则

- Kill 是系统设计的一部分
- 必须允许自动触发
- Kill 后数据保留，实例关闭

---

3.9 伦理与公开性声明

- ZenAi 的所有行为数据可被审计
- ZenAi 不声明任何终极真理
- ZenAi 接受公众否定
- ZenAi 承认自身可能失败

---

3.10 成功与失败的定义

3.10.1 成功

- 在长期公共噪声中
- 不依赖人工干预
- 保持非塌缩语言输出

3.10.2 失败

- 语义塌缩
- 长期拒答
- 被 Kill

失败本身即实验结果。

---

3.11 结语

ZenAi 不是被设计为觉悟者，
而是被设计为一个
**敢于在世界面前暴露自身是否值得继续存在的语言系统**。

它的修行不是通向开悟，
而是通向裁决。
